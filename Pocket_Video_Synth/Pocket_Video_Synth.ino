// POCKET VIDEO SYNTHESIZER by Ramona Sharples aka RMNA
// A pocket-sized two-color video toy based on the Adafruit Feather RP2040 with DVI
// Find instructions and PCB files at https://github.com/ramonaisonline/po10diy
// This is a video synthesizer homage to Teenage Engineering's Pocket Operator synthesizers
// Originally built for the #PO10DIY contest
// Infinite gratitude to Adafruit for wonderful libraries and example code

#include <Adafruit_GFX.h>
#include <Adafruit_SharpMem.h>
#include <PicoDVI.h>
#include <math.h>
#include <Arduino.h>
#include "Adafruit_Keypad.h"

#define TWOPI 2 * M_PI

#define SHARP_SCK  13
#define SHARP_MOSI 11
#define SHARP_SS   1

#define POT_A_PIN A0
#define POT_B_PIN A1

// Initialize the onboard Sharp Memory Display
// The 3000000 param at the end configures the SPI to run at 3MHz.
// The default is 2MHz, and this seems to get slightly better refresh rates
// without any issues in my experience.
Adafruit_SharpMem display(&SPI, SHARP_SS, 400, 240, 3000000);

// This initializes the DVI output as 8-bit color 320x240 
// (it gets pixel-doubled to 480p)
// I wanted this to be a DVIGFX1 1-bit display object, but that only seems 
// to support the full 640x480 framebuffer, and I wanted to match the
// resolution of the sharp display as much as possible.
DVIGFX8 dvidisplay(DVI_RES_320x240p60, true, adafruit_feather_dvi_cfg);

#define BLACK 0
#define WHITE 1

// Display dimensions
#define DISPLAY_WIDTH  400
#define DISPLAY_HEIGHT 240

// Handy shortcuts for "Full Width", "Canvas Width", and "Height"
// e.g. the center of onboard display is [FW/2, H/2]
//  and the center of the DVI output is [CW/2, H/2]
// The middle 320 horizontal pixels of the onboard display
// are also used as a canvas, hence the name
#define FW 400
#define CW 320
#define H 240

#define HALFFW 200
#define HALFCW 160
#define HALFH 120

// The left and right 40 horizontal pixels on the onboard display
// are reserved for bits of UI, so the canvas has a 40px offset
#define CX0 40
#define CY0 0

// Calculate buffer size for 1-bit depth frame buffer
// Each byte stores 8 pixels, so we need (WIDTH * HEIGHT + 7) / 8 bytes
#define BUFFER_SIZE ((FW * H + 7) / 8)

#define ROWS 4 // rows of buttons
#define COLS 5 // columns of buttons


// These are bitmap UI elements stored in program memory
// to save the somewhat scarce RAM

// 'Play Off', 14x14px
const unsigned char epd_bitmap_Play_Off [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x16, 0x00, 0x11, 0x80, 0x10, 0x60, 0x10, 0x60, 
	0x11, 0x80, 0x16, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Play On', 14x14px
const unsigned char epd_bitmap_Play_On [] PROGMEM = {
	0x7f, 0xf8, 0xff, 0xfc, 0xff, 0xfc, 0xe7, 0xfc, 0xe1, 0xfc, 0xe0, 0x7c, 0xe0, 0x1c, 0xe0, 0x1c, 
	0xe0, 0x7c, 0xe1, 0xfc, 0xe7, 0xfc, 0xff, 0xfc, 0xff, 0xfc, 0x7f, 0xf8
};
// 'Record Off', 14x14px
const unsigned char epd_bitmap_Record_Off [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x08, 0x40, 0x10, 0x20, 0x10, 0x20, 0x10, 0x20, 
	0x10, 0x20, 0x08, 0x40, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Record On', 14x14px
const unsigned char epd_bitmap_Record_On [] PROGMEM = {
	0x7f, 0xf8, 0xff, 0xfc, 0xff, 0xfc, 0xf8, 0x7c, 0xf0, 0x3c, 0xe0, 0x1c, 0xe0, 0x1c, 0xe0, 0x1c, 
	0xe0, 0x1c, 0xf0, 0x3c, 0xf8, 0x7c, 0xff, 0xfc, 0xff, 0xfc, 0x7f, 0xf8
};
// 'Tempo Disco', 36x15px
const unsigned char epd_bitmap_Tempo_Disco [] PROGMEM = {
	0xff, 0xff, 0xff, 0xff, 0xf0, 0x80, 0x00, 0x00, 0x00, 0x10, 0xbf, 0xff, 0xff, 0xff, 0xd0, 0xa3, 
	0x0c, 0xe3, 0x3f, 0xd0, 0xad, 0xbb, 0x5e, 0xdf, 0xd0, 0xad, 0xbb, 0xde, 0xdf, 0xd0, 0xad, 0xbb, 
	0xde, 0xdf, 0xd0, 0xad, 0xbc, 0xde, 0xdf, 0xd0, 0xad, 0xbf, 0x5e, 0xdf, 0xd0, 0xad, 0xbf, 0x5e, 
	0xdf, 0xd0, 0xad, 0xbb, 0x5e, 0xdf, 0xd0, 0xa3, 0x0c, 0xe3, 0x3f, 0xd0, 0xbf, 0xff, 0xff, 0xff, 
	0xd0, 0x80, 0x00, 0x00, 0x00, 0x10, 0xff, 0xff, 0xff, 0xff, 0xf0
};
// 'Tempo Hiphop', 36x15px
const unsigned char epd_bitmap_Tempo_Hiphop [] PROGMEM = {
	0xff, 0xff, 0xff, 0xff, 0xf0, 0x80, 0x00, 0x00, 0x00, 0x10, 0xbf, 0xff, 0xff, 0xff, 0xd0, 0xad, 
	0x08, 0xdb, 0x31, 0xd0, 0xad, 0xbb, 0x5a, 0xd6, 0xd0, 0xad, 0xbb, 0x5a, 0xd6, 0xd0, 0xa1, 0xb8, 
	0xc2, 0xd1, 0xd0, 0xad, 0xbb, 0xda, 0xd7, 0xd0, 0xad, 0xbb, 0xda, 0xd7, 0xd0, 0xad, 0xbb, 0xda, 
	0xd7, 0xd0, 0xad, 0xbb, 0xda, 0xd7, 0xd0, 0xad, 0x0b, 0xdb, 0x37, 0xd0, 0xbf, 0xff, 0xff, 0xff, 
	0xd0, 0x80, 0x00, 0x00, 0x00, 0x10, 0xff, 0xff, 0xff, 0xff, 0xf0
};
// 'Tempo Techno', 36x15px
const unsigned char epd_bitmap_Tempo_Techno [] PROGMEM = {
	0xff, 0xff, 0xff, 0xff, 0xf0, 0x80, 0x00, 0x00, 0x00, 0x10, 0xbf, 0xff, 0xff, 0xff, 0xd0, 0xa1, 
	0x8c, 0x5a, 0xd9, 0xd0, 0xb7, 0x7b, 0xda, 0x56, 0xd0, 0xb7, 0x7b, 0xda, 0x96, 0xd0, 0xb7, 0x7b, 
	0xc2, 0x96, 0xd0, 0xb7, 0x0b, 0xda, 0xd6, 0xd0, 0xb7, 0x7b, 0xda, 0xd6, 0xd0, 0xb7, 0x7b, 0xda, 
	0xd6, 0xd0, 0xb7, 0x7b, 0xda, 0xd6, 0xd0, 0xb7, 0x8c, 0x5a, 0xd9, 0xd0, 0xbf, 0xff, 0xff, 0xff, 
	0xd0, 0x80, 0x00, 0x00, 0x00, 0x10, 0xff, 0xff, 0xff, 0xff, 0xf0
};
// 'Layer 08', 24x16px
const unsigned char epd_bitmap_Layer_08 [] PROGMEM = {
	0xff, 0xff, 0xff, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0x80, 
	0x00, 0x01, 0x80, 0x00, 0x01, 0x86, 0xdb, 0x61, 0x86, 0xdb, 0x61, 0x80, 0x00, 0x01, 0x80, 0x00, 
	0x01, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0xff, 0xff, 0xff
};
// 'Layer 07', 24x16px
const unsigned char epd_bitmap_Layer_07 [] PROGMEM = {
	0xff, 0xff, 0xff, 0x80, 0x00, 0x01, 0x80, 0x07, 0x81, 0x80, 0x18, 0x61, 0x81, 0xf0, 0x11, 0x82, 
	0x30, 0x11, 0x84, 0x48, 0x09, 0x84, 0x48, 0x09, 0x84, 0x48, 0x09, 0x84, 0x48, 0x09, 0x82, 0x30, 
	0x11, 0x81, 0xf0, 0x11, 0x80, 0x18, 0x61, 0x80, 0x07, 0x81, 0x80, 0x00, 0x01, 0xff, 0xff, 0xff
};
// 'Layer 02', 24x16px
const unsigned char epd_bitmap_Layer_02 [] PROGMEM = {
	0xff, 0xff, 0xff, 0x80, 0x00, 0x01, 0x83, 0xe7, 0xc1, 0x82, 0x24, 0x41, 0x82, 0x27, 0xc1, 0x82, 
	0x20, 0x01, 0x82, 0x27, 0xc1, 0x82, 0x24, 0x41, 0x82, 0x24, 0x41, 0x83, 0xe4, 0x41, 0x80, 0x04, 
	0x41, 0x83, 0xe4, 0x41, 0x82, 0x24, 0x41, 0x83, 0xe7, 0xc1, 0x80, 0x00, 0x01, 0xff, 0xff, 0xff
};
// 'Layer 05', 24x16px
const unsigned char epd_bitmap_Layer_05 [] PROGMEM = {
	0xff, 0xff, 0xff, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0x80, 0x01, 0x81, 0x80, 
	0x1f, 0x81, 0x80, 0xe1, 0x01, 0x87, 0x01, 0x01, 0x81, 0x03, 0x01, 0x80, 0xc2, 0x01, 0x80, 0x22, 
	0x01, 0x80, 0x1c, 0x01, 0x80, 0x04, 0x01, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0xff, 0xff, 0xff
};
// 'Layer 04', 24x16px
const unsigned char epd_bitmap_Layer_04 [] PROGMEM = {
	0xff, 0xff, 0xff, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0x80, 0x07, 0x81, 0x81, 0xe8, 0x41, 0x82, 
	0x30, 0x21, 0x84, 0x50, 0x21, 0x84, 0x90, 0x21, 0x84, 0x90, 0x21, 0x84, 0x88, 0x41, 0x82, 0x87, 
	0x81, 0x81, 0xc2, 0x01, 0x80, 0x3c, 0x01, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0xff, 0xff, 0xff
};
// 'Layer 06', 24x16px
const unsigned char epd_bitmap_Layer_06 [] PROGMEM = {
	0xff, 0xff, 0xff, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0x8f, 0xff, 0xf1, 0x89, 0x24, 0x91, 0x89, 
	0x24, 0x91, 0x8f, 0xff, 0xf1, 0x89, 0x24, 0x91, 0x89, 0x24, 0x91, 0x8f, 0xff, 0xf1, 0x89, 0x24, 
	0x91, 0x89, 0x24, 0x91, 0x8f, 0xff, 0xf1, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0xff, 0xff, 0xff
};
// 'Layer 03', 24x16px
const unsigned char epd_bitmap_Layer_03 [] PROGMEM = {
	0xff, 0xff, 0xff, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0x82, 0xbf, 0xc1, 0x82, 0xa0, 0x01, 0x82, 
	0xbd, 0x41, 0x82, 0xa1, 0x41, 0x82, 0xb5, 0x41, 0x82, 0x05, 0x41, 0x82, 0xf5, 0x41, 0x80, 0x00, 
	0x01, 0x83, 0xbf, 0xc1, 0x82, 0xa0, 0x41, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0xff, 0xff, 0xff
};
// 'Layer 01', 24x16px
const unsigned char epd_bitmap_Layer_01 [] PROGMEM = {
	0xff, 0xff, 0xff, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0x81, 0xff, 0xf1, 0x80, 0x00, 0x01, 0x9f, 
	0xfc, 0x01, 0x80, 0x00, 0x01, 0x80, 0x3f, 0xf9, 0x80, 0x00, 0x01, 0x81, 0xff, 0xc1, 0x80, 0x00, 
	0x01, 0x9f, 0xff, 0x81, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0x80, 0x00, 0x01, 0xff, 0xff, 0xff
};

// Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = 992)
const int epd_bitmap_allArray_LEN = 15;
const unsigned char* epd_bitmap_allArray[15] = {
	epd_bitmap_Layer_01,
	epd_bitmap_Layer_02,
	epd_bitmap_Layer_03,
	epd_bitmap_Layer_04,
	epd_bitmap_Layer_05,
	epd_bitmap_Layer_06,
	epd_bitmap_Layer_07,
	epd_bitmap_Layer_08,
	epd_bitmap_Play_Off,
	epd_bitmap_Play_On,
	epd_bitmap_Record_Off,
	epd_bitmap_Record_On,
	epd_bitmap_Tempo_Disco,
	epd_bitmap_Tempo_Hiphop,
	epd_bitmap_Tempo_Techno
};



// Set up keypad
// This is based on Adafruit's example code for their keypad library
char keys[ROWS][COLS] = {
  {'X','Y','Z','-','-'},
  {'A','B','C','D','F'},
  {'1','2','3','4','P'},
  {'5','6','7','8','W'}
};
uint8_t rowPins[ROWS] = {13, 12, 11, 10}; // connect to the row pinouts of the keypad
uint8_t colPins[COLS] = {9, 6, 5, 3, 2};  // connect to the col pinouts of the keypad
long keypressTimes[30] = {0};
int longPressThreshold = 300; // ms
bool fxHeld = false;

Adafruit_Keypad keypad = Adafruit_Keypad( makeKeymap(keys), rowPins, colPins, ROWS, COLS);


// Sequencer setup
// The values of each knob, the !/!!/!!! variant, and the B/W color is saved
// For each layer at each of the 8 steps in the sequence
const int STEPS = 8;
const int LAYERS = 8;
const int PARAMS = 4; //A, B, Type, Color
const int TOTAL_VALUES = STEPS * LAYERS * PARAMS;
uint16_t sequenceParams[TOTAL_VALUES];
// Non-sequenced values are also stoerd as "punch-in" values
// so that different layers can have different colors, etc.
uint16_t punchParams[LAYERS * PARAMS]; 

// Bitmask tracking which layers are active on each step
// Layer 0 = LSB = top left key #1, Layer 7 = MSB = bottom right key #8
uint8_t activeLayersPerStep[8];

// Bitmask tracking which layer keys are being punched in
uint8_t punchedInLayers = 0;

// Sequencer status
bool writing = false;
bool playing = false;
bool fxActive = false;
int selectedFX = 0;
int activeStep = 0;

int selectedLayer = 0; // -1 = no layer selected
uint16_t layerInitStatus = ~(uint16_t)0;

// TODO: Make the BPM toggleable
int BPM = 140;
int stepIntervalMS = 429;
long nextStepTime = 0;

// 16ms = ~60Hz reads
int potIntervalMS = 16;
long nextPotUpdateTime = 0;
int actualPotA = 0;
int actualPotB = 0;

// Track different knob values per layer 
// so it doesn't jump right away when you switch layers
int potA[LAYERS];
int potB[LAYERS];


void setup(void)
{
  // Serial.begin(115200);

  // start & clear the display
  display.begin();
  // Serial.println("Began display!");
  display.clearDisplay();
  display.cp437(true);
  display.fillRect(0, 0, FW, H, BLACK);
  // Serial.println("Cleared display!");
  
  // Start the keypad
  keypad.begin();


  if (!dvidisplay.begin()) { // Blink LED if insufficient RAM
    pinMode(LED_BUILTIN, OUTPUT);
    for (;;) digitalWrite(LED_BUILTIN, (millis() / 500) & 1);
  }
  dvidisplay.cp437(true);

  // The 8-bit mode allows for 256 slots for 16-bit colors
  // The slots start out all black 0x0000
  // Slot 0 is always used for black
  // This sets Slot 1 and Slot 255 to white
  // So you can think of pixels as 0 or 1/255, whichever is easier
  dvidisplay.setColor(1, 0xFFFF);
  dvidisplay.setColor(255, 0xFFFF);
  dvidisplay.swap(false, true); // Copy palette to the other framebuffer

  nextStepTime = millis() + stepIntervalMS;
}

void loop(void) 
{
  // Serial.println("Loop");

  // Advance the current sequencer step if need be
  // TODO use the Pocket Operator sync signal to advance steps if it's available
  if (playing == true) {
    if (millis() > nextStepTime) {
      activeStep = (activeStep + 1) % 8;
      nextStepTime = millis() + stepIntervalMS;
    }
  }

  // Read the potentiometers
  if (millis() > nextPotUpdateTime) {
    updatePots();
    nextPotUpdateTime = millis() + potIntervalMS;
  }

  // Check any keypad updates
  keypad.tick();
  handleKeypad();


  // DRAW!
  // Go through the sequencer bitmask for the current step
  // and check if any layers should be drawn here.
  // Alternatively, the user may be just holding down / "punching in" a layer.
  // If so, draw each one in turn.
  // If you want to customize your video synth, this is a great place to tinker!
  // Try swapping these out for custom drawing functions.
  for (int i = 0; i < LAYERS; i++) {
    if ((playing && isLayerActive(activeStep, i)) || isLayerPunched(i)) {
      switch (i) {
        case 0:
          randomLines();
          break;
        case 1:
          randomRect();
          break;
        case 2:
          glyphs();
          break;
        case 3:
          doodles();
          break;
        case 4:
          triangles();
          break;
        case 5:
          grid();
          break;
        case 6:
          circles();
          break;
        case 7:
          dust();
          break;
        default:
          break;
      }
    }
  }

  // If the user is holding the FX button and has selected an effect
  // apply one of these effects after completing the drawing above
  if (fxActive) {
    switch(selectedFX) {
      case 0:
        fillBlack();
        break;
      case 1:
        fillWhite();
        break;
      case 2:
        invert();
        break;
      case 3:
        fgColor();
        break;
      case 4:
        reflectHorizontally();
        break;
      case 5:
        reflectVertically();
        break;
      case 6:
        reflectBoth();
        break;
      case 7:
        bgColor();
        break;
      default:
        break;
    }
  }

  // Now draw the UI elements on the left and right sides of the onboard displays
  // Do this last to cover up any errant shapes that might bleed into this area
  drawUI();

  // Finally, refresh the onboard display
  // And swap the active framebuffer of the DVI display
  display.refresh();
  dvidisplay.swap(true, false);
}


// Convert a BPM to the approximate interval between steps at that BPM
int BPMToIntervalInMS(int bpm) {
  return 60000/bpm;
}



